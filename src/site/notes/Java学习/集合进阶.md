---
{"dg-publish":true,"permalink":"/java//","noteIcon":""}
---

# 集合的体系结构

## 单列集合(Collection)

一次只能添加一个元素

![[Pasted image 20230821160416.png \| 600]]
![Pasted image 20230821160729.png|100](/img/user/Java%E5%AD%A6%E4%B9%A0/%E7%B4%A0%E6%9D%90/Pasted%20image%2020230821160729.png)

collection是单列集合的祖宗**接口**，它的功能是全部单列集合都可以使用的

![[Pasted image 20230821161535.png \| 600]]
学习Collection接口时，不能直接创建他的对象，只能创建实现类的对象
用多态的形式创建对象
```java
Collection<String> coll = new ArrayList<>
```

### Collection中的基本方法

1. 添加元素
```java
coll.add("一个元素");
```


返回值为boolean类型
- 往[[Java学习/集合进阶#List系列集合\|#List系列集合]]中添加数据，方法永远返回true，List系列集合允许元素重复
- 往[[Java学习/集合进阶#Set系列集合\|#Set系列集合]]中添加数据，如果添加的元素不存在，方法返回true，添加的元素重复，返回false

2. 清空元素
```java
coll.clear();
```

3. 删除
Collection中定义的是共性的方法，不能通过索引进行删除，只能通过元素的对象进行删除
```java
coll.remove("一个具体的对象");
```
返回值 成功返回true 失败返回false（删除的元素不存在）

4. 判断元素是否包含
```java
boolean result = coll.contains("一个具体的对象")；
```

contains方法在底层依赖equals方法判断对象是否存在
>如果存的是自定义对象，没有重写equals方法，默认使用Object类中的equals方法判断，依赖对象的地址值判断

需求是比较属性值，需要在自定义的Javabean类中，重写equals方法
步骤：在Javabean类中按`alt`+`insert`选择`equals() and hashCode()

5. 判断集合是否为空
```java
boolean result = coll.isEmpty();
```

6. 获取集合的长度
```java
int size = coll.size();
```

### Collection的遍历方式

1. 普通for遍历。
只有List系列集合能用（有索引）
***
2. 迭代器遍历
迭代器**不依赖索引**
迭代器在Java中的类是Iterator，是集合专用的遍历方式
```java
Interator<String> it = list.iterator(); //调用方法获取迭代器对象，默认指向0索引，创建指针 
boolean flag = it.hasNext(); //判断当前位置是否有元素，返回boolean类型值，没有元素时返回false
String str = it.next(); //获取元素并移动指针
```
```java
迭代器遍历
Interator<String> it = list.iterator();
while(it.hasNext()){
	String str = it.next(); //获取元素并移动指针
	System.out.println("str");
}
```
{ #58376a}


细节
- 报错NoSuchElementEception
	- 指针指向位置没有元素
- 迭代器遍历完毕，指针==不会复位
	- 必须获得一个新的迭代器
- 循环中只能用一次next方法，循环条件不满足
- 遍历时，不能用集合的方法增删
	- 用迭代器的方法删除`it.remove()`
	- 不能添加
***
3. 增强for遍历
底层就是迭代器，为了简化迭代器的书写
所有的==单列集合==和==数组==才能用增强for进行遍历
```java
//格式：
for (元素的数据类型 变量名 : 数组或集合){

}
for (String s : list){
	System.out.println("s");
}
//示例：
Collection<String> coll = new ArrayList<>;
coll.add("zhangsan");
for (String s : coll){
	System.out.println(s);
}

//快捷方式：
coll.for
```
{ #f5825e}


增强for的细节
- 修改for中的==第三方变量`s`==不会改变集合中原本的数据
***
4. Lambda表达式遍历
JDK8的技术Lambda表达式
```java
//匿名内部类方式
coll.forEach(new Consumer<String>() {
	@Override
	public void accept(String s) {
		//s表示每一个数据
		System.out.println(s);
	}
});
//Lambda表达式
coll.forEach(s -> sout(s));
```
{ #dd65b7}


### List系列集合

添加的元素是**有序、可重复、有索引的**

#### List集合的特有方法
1. 在集合的==指定位置插入==指定的元素
```java
void add(index,E element);
list.add(1, "test")
```
- 原来索引上的元素后移
---
2. 删除指定索引处的元素
```java
E remove(int index);
String remove = list.remove(0);
```
- 调用方法时，出现了重载现象，优先调用实参和形参一致的方法
---

3. 修改指定索引处的元素
```java
E set(int index,E element)
```
---
4. 返回指定索引处的元素
```java
E get(index);
```
---

#### List集合的遍历方式

1. [[Java学习/集合进阶#^58376a\|集合进阶#^58376a]]迭代器遍历
2. 列表迭代器遍历
```java
//是迭代器的子接口
//获取一个列表迭代器的对象,指针默认指向0索引
//额外添加了一个方法可以在遍历时添加元素
ListIterator<String> it = list.listIterator();
while(it.hasNext()){
	String str = itnext();
	if("bbb".equals(str)){
		//用迭代器本身的方法添加元素
		it.add("qqq");
	}
}
```
3. [[Java学习/集合进阶#^f5825e\|#^f5825e]]增强for遍历
4. [[Java学习/集合进阶#^dd65b7\|#^dd65b7]]Lambda表达式遍历
5. 普通for循环遍历(存在索引)
```java
for (int i = 0; i < list.size(), i++){
	list.get(i);
	sout(i);
}
```

==遍历方式总结：==
- 删除元素：使用迭代器
- 列表迭代器：需要添加元素
- 只完成遍历：增强for和lambda表达式
- 想要操作索引：使用普通for遍历

#### ArrayList集合底层原理
>ArrayList底层是数组结构的
1. 利用空参创建的集合，在底层创建一个默认长度为0的数组`elementData`成员变量`size`记录长度
2. 添加第一个元素时，底层会创建一个新的长度为10的数组 默认初始化值为`null` 添加完第一个元素时`size++` 
3. 存满时，自动扩容1.5倍
4. 添加的元素过多，新创建的数组长度以实际为准

#源码
```java
ArrayList<String> list = new ArrayList<>();//默认长度为0
list.add("aaa");//添加第一个元素

public boolean add(E e) { //"aaa"被传递过去 形参e记录"aaa"
	modCount++;
	add(e, elementData, size);//参数1：当前要添加的元素 参数2：集合底层的数组名字 参数3：集合的长度/当前元素应存入的位置
	return true;
}

private void add(E e, Object[] elementData, int s){
	if(s == elementData.length)
		elementData = grow(); //grow()方法表示数组扩容
	elementData[s] = e;
	size = s + 1;
}

private Object[] grow() {  
	return grow(size + 1); //把现有的个数+1 再调用一个有参的构造方法 
}
                        //添加完当前元素后需要的最少容量
private Object[] grow(int minCapacity) {  
	int oldCapacity = elementData.length; //记录原来的老容量 开始时oldCapacity为0
	if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA //空的数组) {  
		//以后需要扩容时，执行if中的代码
		int newCapacity = ArraysSupport.newLength(oldCapacity, //老容量  
		minCapacity - oldCapacity, //理论上我们要新增的容量  
		oldCapacity >> 1);         //右移一位相当于除以2 默认新增容量的大小 原容量的0.5
		return elementData = Arrays.copyOf(elementData, newCapacity); //根据第二个参数创建新的数组 把第一个参数中的所有数据全部拷贝到新数组当中  
	} else {  
		return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  
	}  //第一次添加数据时会执行else这里            默认为10          1
	   //创建长度为10的数组
}
                               //老长度 10     最少增加 1     预计/默认增加 5
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {  
	    //理论数组长度
	int prefLength = oldLength + Math.max(minGrowth, prefGrowth);  
	if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {  
		return prefLength;  
	} else {  
		return hugeLength(oldLength, minGrowth);  
	}  
}



```





### Set系列集合

添加的元素是**无序、不重复、无索引的**
1. HashSet
	- LinkedHashSet
2. TreeSet

### 双列集合(Map)

添加数据是添加一对数据
